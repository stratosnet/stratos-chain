// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stratos/pot/v1/pot.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the PoT module parameters
type Params struct {
	BondDenom          string                                 `protobuf:"bytes,1,opt,name=bond_denom,json=bondDenom,proto3" json:"bond_denom" yaml:"bond_denom"`
	RewardDenom        string                                 `protobuf:"bytes,2,opt,name=reward_denom,json=rewardDenom,proto3" json:"reward_denom" yaml:"reward_denom"`
	MatureEpoch        int64                                  `protobuf:"varint,3,opt,name=mature_epoch,json=matureEpoch,proto3" json:"mature_epoch" yaml:"mature_epoch"`
	MiningRewardParams []MiningRewardParam                    `protobuf:"bytes,4,rep,name=mining_reward_params,json=miningRewardParams,proto3" json:"mining_reward_params" yaml:"mining_reward_params"`
	CommunityTax       github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=community_tax,json=communityTax,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"community_tax" yaml:"community_tax"`
	InitialTotalSupply types.Coin                             `protobuf:"bytes,6,opt,name=initial_total_supply,json=initialTotalSupply,proto3" json:"initial_total_supply" yaml:"initial_total_supply"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_a05930b44d981057, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetBondDenom() string {
	if m != nil {
		return m.BondDenom
	}
	return ""
}

func (m *Params) GetRewardDenom() string {
	if m != nil {
		return m.RewardDenom
	}
	return ""
}

func (m *Params) GetMatureEpoch() int64 {
	if m != nil {
		return m.MatureEpoch
	}
	return 0
}

func (m *Params) GetMiningRewardParams() []MiningRewardParam {
	if m != nil {
		return m.MiningRewardParams
	}
	return nil
}

func (m *Params) GetInitialTotalSupply() types.Coin {
	if m != nil {
		return m.InitialTotalSupply
	}
	return types.Coin{}
}

type MiningRewardParam struct {
	TotalMinedValveStart       types.Coin                             `protobuf:"bytes,1,opt,name=total_mined_valve_start,json=totalMinedValveStart,proto3" json:"total_mined_valve_start" yaml:"total_mined_valve_start"`
	TotalMinedValveEnd         types.Coin                             `protobuf:"bytes,2,opt,name=total_mined_valve_end,json=totalMinedValveEnd,proto3" json:"total_mined_valve_end" yaml:"total_mined_valve_end"`
	MiningReward               types.Coin                             `protobuf:"bytes,3,opt,name=mining_reward,json=miningReward,proto3" json:"mining_reward" yaml:"mining_reward"`
	BlockChainPercentageInBp   github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=block_chain_percentage_in_bp,json=blockChainPercentageInBp,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"block_chain_percentage_in_bp" yaml:"block_chain_percentage_in_bp"`
	ResourceNodePercentageInBp github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,5,opt,name=resource_node_percentage_in_bp,json=resourceNodePercentageInBp,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"resource_node_percentage_in_bp" yaml:"resource_node_percentage_in_bp"`
	MetaNodePercentageInBp     github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,6,opt,name=meta_node_percentage_in_bp,json=metaNodePercentageInBp,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"meta_node_percentage_in_bp" yaml:"meta_node_percentage_in_bp"`
}

func (m *MiningRewardParam) Reset()         { *m = MiningRewardParam{} }
func (m *MiningRewardParam) String() string { return proto.CompactTextString(m) }
func (*MiningRewardParam) ProtoMessage()    {}
func (*MiningRewardParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_a05930b44d981057, []int{1}
}
func (m *MiningRewardParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MiningRewardParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MiningRewardParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MiningRewardParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MiningRewardParam.Merge(m, src)
}
func (m *MiningRewardParam) XXX_Size() int {
	return m.Size()
}
func (m *MiningRewardParam) XXX_DiscardUnknown() {
	xxx_messageInfo_MiningRewardParam.DiscardUnknown(m)
}

var xxx_messageInfo_MiningRewardParam proto.InternalMessageInfo

func (m *MiningRewardParam) GetTotalMinedValveStart() types.Coin {
	if m != nil {
		return m.TotalMinedValveStart
	}
	return types.Coin{}
}

func (m *MiningRewardParam) GetTotalMinedValveEnd() types.Coin {
	if m != nil {
		return m.TotalMinedValveEnd
	}
	return types.Coin{}
}

func (m *MiningRewardParam) GetMiningReward() types.Coin {
	if m != nil {
		return m.MiningReward
	}
	return types.Coin{}
}

type Reward struct {
	WalletAddress         string                                   `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address" yaml:"wallet_address"`
	RewardFromMiningPool  github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=reward_from_mining_pool,json=rewardFromMiningPool,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"reward_from_mining_pool" yaml:"reward_from_mining_pool"`
	RewardFromTrafficPool github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=reward_from_traffic_pool,json=rewardFromTrafficPool,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"reward_from_traffic_pool" yaml:"reward_from_traffic_pool"`
}

func (m *Reward) Reset()         { *m = Reward{} }
func (m *Reward) String() string { return proto.CompactTextString(m) }
func (*Reward) ProtoMessage()    {}
func (*Reward) Descriptor() ([]byte, []int) {
	return fileDescriptor_a05930b44d981057, []int{2}
}
func (m *Reward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reward.Merge(m, src)
}
func (m *Reward) XXX_Size() int {
	return m.Size()
}
func (m *Reward) XXX_DiscardUnknown() {
	xxx_messageInfo_Reward.DiscardUnknown(m)
}

var xxx_messageInfo_Reward proto.InternalMessageInfo

func (m *Reward) GetWalletAddress() string {
	if m != nil {
		return m.WalletAddress
	}
	return ""
}

func (m *Reward) GetRewardFromMiningPool() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.RewardFromMiningPool
	}
	return nil
}

func (m *Reward) GetRewardFromTrafficPool() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.RewardFromTrafficPool
	}
	return nil
}

type SingleWalletVolume struct {
	WalletAddress string                                 `protobuf:"bytes,1,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address" yaml:"wallet_address"`
	Volume        github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=volume,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"volume" yaml:"volume"`
}

func (m *SingleWalletVolume) Reset()         { *m = SingleWalletVolume{} }
func (m *SingleWalletVolume) String() string { return proto.CompactTextString(m) }
func (*SingleWalletVolume) ProtoMessage()    {}
func (*SingleWalletVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_a05930b44d981057, []int{3}
}
func (m *SingleWalletVolume) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleWalletVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleWalletVolume.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingleWalletVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleWalletVolume.Merge(m, src)
}
func (m *SingleWalletVolume) XXX_Size() int {
	return m.Size()
}
func (m *SingleWalletVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleWalletVolume.DiscardUnknown(m)
}

var xxx_messageInfo_SingleWalletVolume proto.InternalMessageInfo

func (m *SingleWalletVolume) GetWalletAddress() string {
	if m != nil {
		return m.WalletAddress
	}
	return ""
}

type WalletVolumes struct {
	Volumes []SingleWalletVolume `protobuf:"bytes,1,rep,name=volumes,proto3" json:"volumes" yaml:"volumes"`
}

func (m *WalletVolumes) Reset()         { *m = WalletVolumes{} }
func (m *WalletVolumes) String() string { return proto.CompactTextString(m) }
func (*WalletVolumes) ProtoMessage()    {}
func (*WalletVolumes) Descriptor() ([]byte, []int) {
	return fileDescriptor_a05930b44d981057, []int{4}
}
func (m *WalletVolumes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletVolumes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletVolumes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletVolumes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletVolumes.Merge(m, src)
}
func (m *WalletVolumes) XXX_Size() int {
	return m.Size()
}
func (m *WalletVolumes) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletVolumes.DiscardUnknown(m)
}

var xxx_messageInfo_WalletVolumes proto.InternalMessageInfo

func (m *WalletVolumes) GetVolumes() []SingleWalletVolume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type VolumeReportRecord struct {
	Reporter        string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter" yaml:"reporter"`
	ReportReference string `protobuf:"bytes,2,opt,name=report_reference,json=reportReference,proto3" json:"report_reference" yaml:"report_reference"`
	TxHash          string `protobuf:"bytes,3,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash" yaml:"tx_hash"`
}

func (m *VolumeReportRecord) Reset()         { *m = VolumeReportRecord{} }
func (m *VolumeReportRecord) String() string { return proto.CompactTextString(m) }
func (*VolumeReportRecord) ProtoMessage()    {}
func (*VolumeReportRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_a05930b44d981057, []int{5}
}
func (m *VolumeReportRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeReportRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeReportRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeReportRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeReportRecord.Merge(m, src)
}
func (m *VolumeReportRecord) XXX_Size() int {
	return m.Size()
}
func (m *VolumeReportRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeReportRecord.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeReportRecord proto.InternalMessageInfo

func (m *VolumeReportRecord) GetReporter() string {
	if m != nil {
		return m.Reporter
	}
	return ""
}

func (m *VolumeReportRecord) GetReportReference() string {
	if m != nil {
		return m.ReportReference
	}
	return ""
}

func (m *VolumeReportRecord) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

type TotalReward struct {
	MiningReward  github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=mining_reward,json=miningReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"mining_reward" yaml:"mining_reward"`
	TrafficReward github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=traffic_reward,json=trafficReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"traffic_reward" yaml:"traffic_reward"`
}

func (m *TotalReward) Reset()         { *m = TotalReward{} }
func (m *TotalReward) String() string { return proto.CompactTextString(m) }
func (*TotalReward) ProtoMessage()    {}
func (*TotalReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_a05930b44d981057, []int{6}
}
func (m *TotalReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TotalReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TotalReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TotalReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalReward.Merge(m, src)
}
func (m *TotalReward) XXX_Size() int {
	return m.Size()
}
func (m *TotalReward) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalReward.DiscardUnknown(m)
}

var xxx_messageInfo_TotalReward proto.InternalMessageInfo

func (m *TotalReward) GetMiningReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.MiningReward
	}
	return nil
}

func (m *TotalReward) GetTrafficReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TrafficReward
	}
	return nil
}

type Metrics struct {
	TotalSupply               github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=total_supply,json=totalSupply,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_supply" yaml:"total_supply"`
	TotalMiningSupply         github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=total_mining_supply,json=totalMiningSupply,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_mining_supply" yaml:"total_mining_supply"`
	TotalMinedTokens          github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=total_mined_tokens,json=totalMinedTokens,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_mined_tokens" yaml:"total_mined_tokens"`
	TotalResourceNodesDeposit github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=total_resource_nodes_deposit,json=totalResourceNodesDeposit,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_resource_nodes_deposit" yaml:"total_resource_nodes_deposit"`
	TotalBondedDelegation     github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,5,opt,name=total_bonded_delegation,json=totalBondedDelegation,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_bonded_delegation" yaml:"total_bonded_delegation"`
	TotalUnbondedDelegation   github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,6,opt,name=total_unbonded_delegation,json=totalUnbondedDelegation,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_unbonded_delegation" yaml:"total_unbonded_delegation"`
	TotalUnbondingDelegation  github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,7,opt,name=total_unbonding_delegation,json=totalUnbondingDelegation,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_unbonding_delegation" yaml:"total_unbonding_delegation"`
	CirculationSupply         github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,8,opt,name=circulation_supply,json=circulationSupply,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"circulation_supply" yaml:"circulation_supply"`
	TotalMiningReward         github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,9,opt,name=total_mining_reward,json=totalMiningReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_mining_reward" yaml:"total_mining_reward"`
	ChainMiningReward         github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,10,opt,name=chain_mining_reward,json=chainMiningReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"chain_mining_reward" yaml:"chain_mining_reward"`
	ResourceMiningReward      github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,11,opt,name=resource_mining_reward,json=resourceMiningReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"resource_mining_reward" yaml:"resource_mining_reward"`
	MetaMiningReward          github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,12,opt,name=meta_mining_reward,json=metaMiningReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"meta_mining_reward" yaml:"meta_mining_reward"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_a05930b44d981057, []int{7}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Params)(nil), "stratos.pot.v1.Params")
	proto.RegisterType((*MiningRewardParam)(nil), "stratos.pot.v1.MiningRewardParam")
	proto.RegisterType((*Reward)(nil), "stratos.pot.v1.Reward")
	proto.RegisterType((*SingleWalletVolume)(nil), "stratos.pot.v1.SingleWalletVolume")
	proto.RegisterType((*WalletVolumes)(nil), "stratos.pot.v1.WalletVolumes")
	proto.RegisterType((*VolumeReportRecord)(nil), "stratos.pot.v1.VolumeReportRecord")
	proto.RegisterType((*TotalReward)(nil), "stratos.pot.v1.TotalReward")
	proto.RegisterType((*Metrics)(nil), "stratos.pot.v1.Metrics")
}

func init() { proto.RegisterFile("stratos/pot/v1/pot.proto", fileDescriptor_a05930b44d981057) }

var fileDescriptor_a05930b44d981057 = []byte{
	// 1585 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x88, 0x1c, 0x45,
	0x17, 0xdf, 0xca, 0x26, 0xbb, 0xd9, 0xda, 0x3f, 0xc9, 0x76, 0x26, 0xc9, 0xec, 0x7e, 0xc9, 0xd4,
	0xa6, 0xc3, 0x97, 0x6f, 0x09, 0x64, 0x86, 0xcd, 0x07, 0xdf, 0x07, 0x39, 0xe9, 0x64, 0x13, 0x8c,
	0xb0, 0x12, 0x66, 0xd7, 0x08, 0x41, 0x6c, 0x7b, 0x7b, 0x6a, 0x67, 0x3b, 0x99, 0xee, 0x1a, 0xba,
	0x6b, 0x26, 0xbb, 0x20, 0x1e, 0x44, 0x44, 0xfc, 0x83, 0xb9, 0x08, 0xf1, 0x22, 0x12, 0x41, 0x82,
	0xa7, 0x20, 0xe2, 0x4d, 0x44, 0x54, 0x88, 0x9e, 0xa2, 0x5e, 0xc4, 0x43, 0x29, 0x9b, 0x43, 0x60,
	0x8e, 0x7d, 0xf0, 0x26, 0x48, 0xfd, 0xe9, 0xe9, 0xee, 0xe9, 0xee, 0x59, 0x67, 0x15, 0x2f, 0xbb,
	0x5d, 0xef, 0xbd, 0x7a, 0xf5, 0xfb, 0x55, 0xbd, 0xf7, 0xea, 0xd5, 0xc0, 0xa2, 0x4f, 0x3d, 0x93,
	0x12, 0xbf, 0xd2, 0x22, 0xb4, 0xd2, 0x59, 0xe2, 0xff, 0xca, 0x2d, 0x8f, 0x50, 0xa2, 0xcd, 0x28,
	0x4d, 0x99, 0x8b, 0x3a, 0x4b, 0xf3, 0x85, 0x06, 0x69, 0x10, 0xa1, 0xaa, 0xf0, 0x2f, 0x69, 0x35,
	0x3f, 0x67, 0x11, 0xdf, 0x21, 0xbe, 0x21, 0x15, 0x72, 0xa0, 0x54, 0xb3, 0xa6, 0x63, 0xbb, 0xa4,
	0x22, 0xfe, 0x2a, 0x51, 0x49, 0x1a, 0x54, 0xd6, 0x4d, 0x1f, 0x57, 0x3a, 0x4b, 0xeb, 0x98, 0x9a,
	0x4b, 0x15, 0x8b, 0xd8, 0xae, 0xd4, 0xeb, 0x9f, 0x1f, 0x80, 0x63, 0x57, 0x4d, 0xcf, 0x74, 0x7c,
	0xad, 0x0a, 0xe1, 0x3a, 0x71, 0xeb, 0x46, 0x1d, 0xbb, 0xc4, 0x29, 0x82, 0x05, 0xb0, 0x38, 0x51,
	0x3d, 0xdd, 0x65, 0x28, 0x26, 0x0d, 0x18, 0x9a, 0xdd, 0x36, 0x9d, 0xe6, 0x05, 0x3d, 0x92, 0xe9,
	0xb5, 0x09, 0x3e, 0x58, 0xe6, 0xdf, 0xda, 0xd3, 0x70, 0xca, 0xc3, 0xb7, 0x4c, 0x2f, 0xf4, 0xb2,
	0x4f, 0x78, 0xf9, 0x4f, 0x97, 0xa1, 0x84, 0x3c, 0x60, 0xe8, 0x88, 0xf4, 0x13, 0x97, 0xea, 0xb5,
	0x49, 0x39, 0xec, 0xf9, 0x72, 0x4c, 0xda, 0xf6, 0xb0, 0x81, 0x5b, 0xc4, 0xda, 0x2c, 0x8e, 0x2e,
	0x80, 0xc5, 0x51, 0xe9, 0x2b, 0x2e, 0x8f, 0x7c, 0xc5, 0xa5, 0x7a, 0x6d, 0x52, 0x0e, 0x2f, 0xf1,
	0x91, 0xf6, 0x2e, 0x80, 0x05, 0xc7, 0x76, 0x6d, 0xb7, 0x61, 0xa8, 0x15, 0x5b, 0x82, 0x74, 0x71,
	0xff, 0xc2, 0xe8, 0xe2, 0xe4, 0xf9, 0x53, 0xe5, 0xe4, 0xd6, 0x97, 0x57, 0x84, 0x6d, 0x4d, 0x98,
	0x8a, 0xed, 0xa9, 0x3e, 0xf1, 0x80, 0xa1, 0x91, 0x2e, 0x43, 0x99, 0x6e, 0x02, 0x86, 0xfe, 0xa5,
	0x30, 0x64, 0x68, 0xf5, 0x7b, 0x8f, 0xef, 0x9f, 0x05, 0x35, 0xcd, 0xe9, 0x77, 0xea, 0x6b, 0xef,
	0x00, 0x38, 0x6d, 0x11, 0xc7, 0x69, 0xbb, 0x36, 0xdd, 0x36, 0xa8, 0xb9, 0x55, 0x3c, 0x20, 0x76,
	0xec, 0x06, 0x5f, 0xed, 0x67, 0x86, 0xce, 0x34, 0x6c, 0xba, 0xd9, 0x5e, 0x2f, 0x5b, 0xc4, 0x51,
	0x47, 0xad, 0xfe, 0x9d, 0xf3, 0xeb, 0x37, 0x2b, 0x74, 0xbb, 0x85, 0xfd, 0xf2, 0x32, 0xb6, 0xba,
	0x0c, 0x25, 0xdd, 0x04, 0x0c, 0x15, 0x24, 0xa0, 0x84, 0x58, 0xff, 0xe1, 0xd3, 0x73, 0x50, 0x85,
	0xcc, 0x32, 0xb6, 0x24, 0xae, 0xa9, 0x9e, 0xc9, 0x9a, 0xb9, 0xa5, 0xbd, 0x0d, 0x60, 0xc1, 0x76,
	0x6d, 0x6a, 0x9b, 0x4d, 0x83, 0x12, 0x6a, 0x36, 0x0d, 0xbf, 0xdd, 0x6a, 0x35, 0xb7, 0x8b, 0x63,
	0x0b, 0x60, 0x71, 0xf2, 0xfc, 0x5c, 0x59, 0x4d, 0xe7, 0x01, 0x55, 0x56, 0x01, 0x55, 0xbe, 0x48,
	0x6c, 0x37, 0xda, 0xa1, 0xac, 0xe9, 0xd1, 0x0e, 0x65, 0x69, 0xc3, 0x1d, 0x52, 0xba, 0x35, 0xae,
	0x5a, 0x15, 0x9a, 0x0b, 0x27, 0xef, 0x7c, 0x80, 0xc0, 0x1b, 0x8f, 0xef, 0x9f, 0x2d, 0x84, 0x79,
	0xb3, 0x25, 0x32, 0x47, 0x6e, 0xa0, 0xfe, 0xde, 0x41, 0x38, 0x9b, 0x3a, 0x2c, 0xed, 0x0e, 0x80,
	0xc7, 0xa5, 0x7f, 0xc7, 0x76, 0x71, 0xdd, 0xe8, 0x98, 0xcd, 0x0e, 0x36, 0x7c, 0x6a, 0x7a, 0x54,
	0x04, 0xf6, 0x40, 0x1e, 0x97, 0x15, 0x8f, 0x3c, 0x0f, 0x01, 0x43, 0x25, 0x49, 0x25, 0xc7, 0x40,
	0xb1, 0x29, 0x08, 0xf5, 0x0a, 0xd7, 0x5e, 0xe3, 0xca, 0x55, 0xae, 0xd3, 0x6e, 0x03, 0x78, 0x34,
	0x3d, 0x0f, 0xbb, 0x75, 0x91, 0x2b, 0x03, 0x81, 0x55, 0x15, 0xb0, 0xec, 0xf9, 0x01, 0x43, 0x27,
	0xf2, 0x60, 0x61, 0xb7, 0x1e, 0x6e, 0x71, 0x1f, 0xa8, 0x4b, 0x6e, 0x5d, 0xf3, 0xe0, 0x74, 0x22,
	0x6c, 0x45, 0xa6, 0x0d, 0x44, 0x72, 0x5e, 0x21, 0x49, 0xce, 0x8b, 0x82, 0x2e, 0x21, 0x56, 0x2b,
	0x4f, 0xc5, 0xc3, 0x5f, 0xfb, 0x16, 0xc0, 0x13, 0xeb, 0x4d, 0x62, 0xdd, 0x34, 0xac, 0x4d, 0xd3,
	0x76, 0x8d, 0x16, 0xf6, 0x2c, 0xec, 0x52, 0xb3, 0x81, 0x0d, 0xdb, 0x35, 0xd6, 0x5b, 0xc5, 0xfd,
	0x22, 0x0f, 0x5e, 0x07, 0x43, 0x24, 0xc2, 0x15, 0x97, 0x76, 0x19, 0x1a, 0xe8, 0x36, 0x60, 0xe8,
	0xb4, 0x2a, 0x60, 0x03, 0xac, 0xe2, 0x69, 0x72, 0xc5, 0xa5, 0x12, 0x7f, 0x51, 0xcc, 0xb8, 0xc8,
	0x27, 0x5c, 0xed, 0xd9, 0x5f, 0x71, 0xab, 0x2d, 0xed, 0x7b, 0x00, 0x4b, 0x1e, 0xf6, 0x49, 0xdb,
	0xb3, 0xb0, 0xe1, 0x92, 0x3a, 0x4e, 0xb3, 0x91, 0x59, 0xfd, 0xd6, 0xf0, 0x6c, 0x76, 0x71, 0x1c,
	0x30, 0xf4, 0xef, 0xb0, 0x90, 0x0e, 0xb2, 0xcb, 0x64, 0x34, 0x1f, 0xce, 0x79, 0x86, 0xd4, 0x71,
	0x1f, 0xa7, 0x2f, 0x01, 0x9c, 0x77, 0x30, 0x35, 0x73, 0xf8, 0x8c, 0x09, 0x3e, 0xaf, 0x0e, 0xcf,
	0x67, 0x80, 0xd3, 0x80, 0xa1, 0x53, 0x2a, 0x7c, 0x72, 0x6d, 0x32, 0x79, 0x1c, 0xe3, 0xf6, 0x69,
	0x0e, 0xfa, 0x6b, 0xfb, 0xe1, 0x98, 0x0a, 0xb7, 0x1b, 0x70, 0xe6, 0x96, 0xd9, 0x6c, 0x62, 0x6a,
	0x98, 0xf5, 0xba, 0x87, 0x7d, 0x5f, 0xdd, 0x6f, 0x17, 0xbb, 0x0c, 0xf5, 0x69, 0x02, 0x86, 0x8e,
	0x4a, 0x18, 0x49, 0x39, 0x5f, 0xba, 0xa0, 0x96, 0x7e, 0x52, 0x8a, 0x56, 0xa9, 0xc7, 0x23, 0x7a,
	0x5a, 0x1a, 0x2a, 0xa1, 0xf6, 0x35, 0x80, 0xc7, 0x55, 0xfd, 0xdf, 0xf0, 0x88, 0x63, 0xa8, 0x64,
	0x68, 0x11, 0xd2, 0x2c, 0xee, 0x13, 0xd7, 0xcd, 0x80, 0xcc, 0xf2, 0xc2, 0xe2, 0x93, 0xe3, 0x21,
	0x2a, 0x3e, 0x39, 0x06, 0xfa, 0xc7, 0xbf, 0xa0, 0xc5, 0x3f, 0x71, 0x1c, 0x7c, 0x35, 0x5f, 0x15,
	0x2a, 0xe9, 0xea, 0xb2, 0x47, 0x1c, 0x59, 0x4a, 0xaf, 0x12, 0xd2, 0xd4, 0x1e, 0x00, 0x58, 0x8c,
	0xaf, 0x41, 0x3d, 0x73, 0x63, 0xc3, 0xb6, 0x24, 0x8f, 0xd1, 0xdd, 0x78, 0x50, 0xc5, 0x23, 0xd7,
	0x45, 0xc0, 0x10, 0x4a, 0x13, 0x89, 0x5b, 0xec, 0x81, 0xc9, 0xd1, 0x88, 0xc9, 0x9a, 0xf4, 0xc4,
	0xa9, 0xe8, 0xbf, 0x01, 0xa8, 0xad, 0xda, 0x6e, 0xa3, 0x89, 0x9f, 0x13, 0x27, 0x75, 0x8d, 0x34,
	0xdb, 0x0e, 0xfe, 0x47, 0x83, 0x82, 0xc2, 0xb1, 0x8e, 0x58, 0x55, 0xb5, 0x44, 0xcf, 0x0f, 0x9d,
	0x39, 0x6a, 0x7e, 0xc0, 0xd0, 0xb4, 0x44, 0x22, 0xc7, 0x99, 0x19, 0xa1, 0x6c, 0xf5, 0x36, 0x9c,
	0x8e, 0x33, 0xf6, 0xb5, 0x3a, 0x1c, 0x97, 0x2a, 0xce, 0x95, 0x1f, 0xa1, 0xde, 0xdf, 0xf9, 0xa4,
	0xf7, 0xa9, 0x7a, 0x46, 0x9d, 0x65, 0x38, 0x35, 0x60, 0x68, 0x26, 0x0e, 0x21, 0x6c, 0x70, 0x42,
	0xbd, 0xfe, 0x3b, 0x80, 0x9a, 0x9c, 0x5b, 0xc3, 0x2d, 0xe2, 0xd1, 0x1a, 0xb6, 0x88, 0x57, 0xd7,
	0x56, 0xe1, 0x41, 0x4f, 0x8c, 0xb1, 0xa7, 0x76, 0xfa, 0xff, 0x5d, 0x86, 0x7a, 0xb2, 0x80, 0xa1,
	0x43, 0x61, 0x44, 0x48, 0x49, 0xfe, 0xee, 0xf6, 0x26, 0x69, 0xd7, 0xe1, 0x61, 0xf9, 0x6d, 0x78,
	0x78, 0x03, 0x7b, 0xd8, 0xb5, 0xc2, 0x2d, 0xae, 0x74, 0x19, 0x4a, 0xe9, 0x02, 0x86, 0x8e, 0xc7,
	0x17, 0x89, 0x34, 0x7a, 0xed, 0x90, 0xa7, 0xd0, 0x2a, 0x89, 0xf6, 0x3f, 0x38, 0x4e, 0xb7, 0x8c,
	0x4d, 0xd3, 0x97, 0xcd, 0xe7, 0x44, 0xf5, 0x24, 0xdf, 0x05, 0x25, 0x8a, 0x76, 0x41, 0x09, 0xf4,
	0xda, 0x18, 0xdd, 0x7a, 0x8a, 0x7f, 0xfc, 0xb8, 0x0f, 0x4e, 0x8a, 0x1e, 0x46, 0x55, 0x9f, 0xf7,
	0x41, 0xff, 0x0d, 0x0b, 0x76, 0xcb, 0x9f, 0x17, 0x86, 0xba, 0x61, 0x87, 0xcf, 0x94, 0xe4, 0x6d,
	0x7c, 0x17, 0xc0, 0x99, 0x30, 0xf5, 0x14, 0xc2, 0x5d, 0x2b, 0xd5, 0x8b, 0x0a, 0x61, 0xdf, 0xc4,
	0x28, 0x53, 0x92, 0xf2, 0x3d, 0x60, 0x9c, 0x56, 0x1e, 0x24, 0x48, 0xfd, 0x9b, 0xc3, 0x70, 0x7c,
	0x05, 0x53, 0xcf, 0xb6, 0x7c, 0xed, 0x4d, 0x00, 0xa7, 0x12, 0xdd, 0xa9, 0x8c, 0xa7, 0xcd, 0xa1,
	0xb3, 0x6a, 0xaa, 0xaf, 0x49, 0x3d, 0x12, 0x6f, 0xa1, 0x54, 0x73, 0x9a, 0x95, 0x61, 0x93, 0x34,
	0xea, 0x51, 0xb5, 0x8f, 0x00, 0x3c, 0xd2, 0x6b, 0xba, 0xf8, 0xb1, 0x28, 0x50, 0x32, 0x0e, 0x3b,
	0x43, 0x83, 0xca, 0x72, 0x16, 0x30, 0x34, 0xdf, 0xd7, 0xde, 0x45, 0xca, 0x4c, 0x88, 0xb3, 0x61,
	0xab, 0x67, 0xbb, 0x0d, 0x05, 0xf4, 0x2e, 0x80, 0x5a, 0xbc, 0x3b, 0xa4, 0xe4, 0x26, 0x76, 0x7d,
	0x15, 0xdc, 0x74, 0x68, 0x9c, 0x19, 0xbe, 0x02, 0x86, 0xe6, 0xd2, 0x5d, 0xa8, 0xd4, 0x65, 0xa2,
	0x3c, 0x1c, 0x35, 0xa4, 0x6b, 0xc2, 0x4a, 0xfb, 0x0e, 0xc0, 0x13, 0x72, 0x72, 0xa2, 0xa7, 0xf1,
	0x8d, 0x3a, 0x6e, 0x11, 0xdf, 0xa6, 0x7f, 0xa1, 0x35, 0x1c, 0xe4, 0x36, 0x6a, 0x0d, 0x07, 0x59,
	0x65, 0x72, 0x98, 0xa3, 0x32, 0xd9, 0xa3, 0x6e, 0xca, 0x5f, 0x96, 0xe6, 0xda, 0x67, 0xbd, 0x97,
	0x08, 0x7f, 0x24, 0x63, 0xfe, 0xd2, 0x6d, 0xe2, 0x86, 0x49, 0x6d, 0xe2, 0xaa, 0xa6, 0xf0, 0xe5,
	0xa1, 0x69, 0xe4, 0x39, 0xec, 0x7f, 0x98, 0xa4, 0x0c, 0x32, 0xc1, 0xcb, 0xd7, 0x44, 0x55, 0xd8,
	0x2e, 0xf7, 0x4c, 0xb5, 0x2f, 0x00, 0x94, 0xb4, 0x8c, 0xb6, 0x9b, 0x86, 0x2e, 0xfb, 0xbf, 0x57,
	0x86, 0x3f, 0x82, 0x7c, 0x9f, 0x01, 0x43, 0x0b, 0x71, 0xf4, 0x19, 0x26, 0x99, 0xf8, 0xe5, 0x6e,
	0x3c, 0xab, 0xac, 0x63, 0x0c, 0xbe, 0x02, 0x70, 0x3e, 0xee, 0x8a, 0xa7, 0x4b, 0x8c, 0xc2, 0xf8,
	0x9e, 0x5b, 0xd8, 0x7c, 0xa7, 0x51, 0x0b, 0x9b, 0x6f, 0x93, 0xfd, 0xb8, 0x88, 0x91, 0xb0, 0xdd,
	0x46, 0x8c, 0xc5, 0x87, 0x00, 0x6a, 0x96, 0xed, 0x59, 0xed, 0xa6, 0x18, 0x87, 0xa5, 0xe5, 0xe0,
	0x5e, 0x53, 0x36, 0xed, 0x2b, 0x4a, 0xd9, 0xb4, 0x2e, 0xbb, 0xb0, 0xc4, 0xec, 0xf2, 0x2a, 0xa0,
	0xba, 0x45, 0x26, 0xfe, 0x96, 0x0a, 0xd8, 0xbb, 0x59, 0xb2, 0x2a, 0xa0, 0xba, 0x5e, 0x76, 0xab,
	0x80, 0xea, 0xa6, 0xe3, 0x40, 0xe5, 0xa3, 0x2f, 0x09, 0x14, 0xee, 0x15, 0x68, 0x86, 0xb3, 0x08,
	0x68, 0x86, 0x32, 0x67, 0x47, 0xb9, 0x61, 0x02, 0xe8, 0x27, 0x00, 0x1e, 0xeb, 0x95, 0xa0, 0x24,
	0xd6, 0x49, 0x81, 0xf5, 0xa5, 0xa1, 0xb1, 0xe6, 0xf8, 0x0b, 0x18, 0x3a, 0xd9, 0xf7, 0x86, 0xdc,
	0x1d, 0x71, 0x21, 0xb4, 0x5d, 0xe9, 0xeb, 0x23, 0x34, 0xf1, 0x78, 0x4b, 0x02, 0x9e, 0xda, 0x6b,
	0xb0, 0xa6, 0x7d, 0x45, 0xc1, 0x9a, 0xd6, 0x65, 0xdf, 0x2f, 0xdc, 0x2e, 0x0e, 0xb2, 0xba, 0x72,
	0x6f, 0xa7, 0x04, 0x1e, 0xec, 0x94, 0xc0, 0xc3, 0x9d, 0x12, 0xf8, 0x75, 0xa7, 0x04, 0x6e, 0x3f,
	0x2a, 0x8d, 0x3c, 0x7c, 0x54, 0x1a, 0xf9, 0xe9, 0x51, 0x69, 0xe4, 0x7a, 0x25, 0x86, 0x4e, 0xb5,
	0xc6, 0x2e, 0xa6, 0xe1, 0xe7, 0x39, 0x71, 0x50, 0xea, 0x27, 0x28, 0x01, 0x75, 0x7d, 0x4c, 0xfc,
	0x90, 0xfa, 0xdf, 0x3f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x24, 0x8d, 0x66, 0xca, 0xd8, 0x15, 0x00,
	0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BondDenom != that1.BondDenom {
		return false
	}
	if this.RewardDenom != that1.RewardDenom {
		return false
	}
	if this.MatureEpoch != that1.MatureEpoch {
		return false
	}
	if len(this.MiningRewardParams) != len(that1.MiningRewardParams) {
		return false
	}
	for i := range this.MiningRewardParams {
		if !this.MiningRewardParams[i].Equal(&that1.MiningRewardParams[i]) {
			return false
		}
	}
	if !this.CommunityTax.Equal(that1.CommunityTax) {
		return false
	}
	if !this.InitialTotalSupply.Equal(&that1.InitialTotalSupply) {
		return false
	}
	return true
}
func (this *MiningRewardParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MiningRewardParam)
	if !ok {
		that2, ok := that.(MiningRewardParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TotalMinedValveStart.Equal(&that1.TotalMinedValveStart) {
		return false
	}
	if !this.TotalMinedValveEnd.Equal(&that1.TotalMinedValveEnd) {
		return false
	}
	if !this.MiningReward.Equal(&that1.MiningReward) {
		return false
	}
	if !this.BlockChainPercentageInBp.Equal(that1.BlockChainPercentageInBp) {
		return false
	}
	if !this.ResourceNodePercentageInBp.Equal(that1.ResourceNodePercentageInBp) {
		return false
	}
	if !this.MetaNodePercentageInBp.Equal(that1.MetaNodePercentageInBp) {
		return false
	}
	return true
}
func (this *Reward) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Reward)
	if !ok {
		that2, ok := that.(Reward)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WalletAddress != that1.WalletAddress {
		return false
	}
	if len(this.RewardFromMiningPool) != len(that1.RewardFromMiningPool) {
		return false
	}
	for i := range this.RewardFromMiningPool {
		if !this.RewardFromMiningPool[i].Equal(&that1.RewardFromMiningPool[i]) {
			return false
		}
	}
	if len(this.RewardFromTrafficPool) != len(that1.RewardFromTrafficPool) {
		return false
	}
	for i := range this.RewardFromTrafficPool {
		if !this.RewardFromTrafficPool[i].Equal(&that1.RewardFromTrafficPool[i]) {
			return false
		}
	}
	return true
}
func (this *SingleWalletVolume) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SingleWalletVolume)
	if !ok {
		that2, ok := that.(SingleWalletVolume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WalletAddress != that1.WalletAddress {
		return false
	}
	if !this.Volume.Equal(that1.Volume) {
		return false
	}
	return true
}
func (this *WalletVolumes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WalletVolumes)
	if !ok {
		that2, ok := that.(WalletVolumes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(&that1.Volumes[i]) {
			return false
		}
	}
	return true
}
func (this *VolumeReportRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolumeReportRecord)
	if !ok {
		that2, ok := that.(VolumeReportRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Reporter != that1.Reporter {
		return false
	}
	if this.ReportReference != that1.ReportReference {
		return false
	}
	if this.TxHash != that1.TxHash {
		return false
	}
	return true
}
func (this *TotalReward) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TotalReward)
	if !ok {
		that2, ok := that.(TotalReward)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.MiningReward) != len(that1.MiningReward) {
		return false
	}
	for i := range this.MiningReward {
		if !this.MiningReward[i].Equal(&that1.MiningReward[i]) {
			return false
		}
	}
	if len(this.TrafficReward) != len(that1.TrafficReward) {
		return false
	}
	for i := range this.TrafficReward {
		if !this.TrafficReward[i].Equal(&that1.TrafficReward[i]) {
			return false
		}
	}
	return true
}
func (this *Metrics) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Metrics)
	if !ok {
		that2, ok := that.(Metrics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TotalSupply.Equal(that1.TotalSupply) {
		return false
	}
	if !this.TotalMiningSupply.Equal(that1.TotalMiningSupply) {
		return false
	}
	if !this.TotalMinedTokens.Equal(that1.TotalMinedTokens) {
		return false
	}
	if !this.TotalResourceNodesDeposit.Equal(that1.TotalResourceNodesDeposit) {
		return false
	}
	if !this.TotalBondedDelegation.Equal(that1.TotalBondedDelegation) {
		return false
	}
	if !this.TotalUnbondedDelegation.Equal(that1.TotalUnbondedDelegation) {
		return false
	}
	if !this.TotalUnbondingDelegation.Equal(that1.TotalUnbondingDelegation) {
		return false
	}
	if !this.CirculationSupply.Equal(that1.CirculationSupply) {
		return false
	}
	if !this.TotalMiningReward.Equal(that1.TotalMiningReward) {
		return false
	}
	if !this.ChainMiningReward.Equal(that1.ChainMiningReward) {
		return false
	}
	if !this.ResourceMiningReward.Equal(that1.ResourceMiningReward) {
		return false
	}
	if !this.MetaMiningReward.Equal(that1.MetaMiningReward) {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InitialTotalSupply.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.CommunityTax.Size()
		i -= size
		if _, err := m.CommunityTax.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.MiningRewardParams) > 0 {
		for iNdEx := len(m.MiningRewardParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MiningRewardParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MatureEpoch != 0 {
		i = encodeVarintPot(dAtA, i, uint64(m.MatureEpoch))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RewardDenom) > 0 {
		i -= len(m.RewardDenom)
		copy(dAtA[i:], m.RewardDenom)
		i = encodeVarintPot(dAtA, i, uint64(len(m.RewardDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BondDenom) > 0 {
		i -= len(m.BondDenom)
		copy(dAtA[i:], m.BondDenom)
		i = encodeVarintPot(dAtA, i, uint64(len(m.BondDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MiningRewardParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MiningRewardParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MiningRewardParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MetaNodePercentageInBp.Size()
		i -= size
		if _, err := m.MetaNodePercentageInBp.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.ResourceNodePercentageInBp.Size()
		i -= size
		if _, err := m.ResourceNodePercentageInBp.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.BlockChainPercentageInBp.Size()
		i -= size
		if _, err := m.BlockChainPercentageInBp.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.MiningReward.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.TotalMinedValveEnd.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.TotalMinedValveStart.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Reward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardFromTrafficPool) > 0 {
		for iNdEx := len(m.RewardFromTrafficPool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardFromTrafficPool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RewardFromMiningPool) > 0 {
		for iNdEx := len(m.RewardFromMiningPool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardFromMiningPool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.WalletAddress) > 0 {
		i -= len(m.WalletAddress)
		copy(dAtA[i:], m.WalletAddress)
		i = encodeVarintPot(dAtA, i, uint64(len(m.WalletAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SingleWalletVolume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleWalletVolume) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingleWalletVolume) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Volume.Size()
		i -= size
		if _, err := m.Volume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.WalletAddress) > 0 {
		i -= len(m.WalletAddress)
		copy(dAtA[i:], m.WalletAddress)
		i = encodeVarintPot(dAtA, i, uint64(len(m.WalletAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WalletVolumes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletVolumes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletVolumes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Volumes) > 0 {
		for iNdEx := len(m.Volumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Volumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VolumeReportRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeReportRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeReportRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintPot(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReportReference) > 0 {
		i -= len(m.ReportReference)
		copy(dAtA[i:], m.ReportReference)
		i = encodeVarintPot(dAtA, i, uint64(len(m.ReportReference)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintPot(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TotalReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TotalReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrafficReward) > 0 {
		for iNdEx := len(m.TrafficReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrafficReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MiningReward) > 0 {
		for iNdEx := len(m.MiningReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MiningReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPot(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MetaMiningReward.Size()
		i -= size
		if _, err := m.MetaMiningReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size := m.ResourceMiningReward.Size()
		i -= size
		if _, err := m.ResourceMiningReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.ChainMiningReward.Size()
		i -= size
		if _, err := m.ChainMiningReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.TotalMiningReward.Size()
		i -= size
		if _, err := m.TotalMiningReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.CirculationSupply.Size()
		i -= size
		if _, err := m.CirculationSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.TotalUnbondingDelegation.Size()
		i -= size
		if _, err := m.TotalUnbondingDelegation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TotalUnbondedDelegation.Size()
		i -= size
		if _, err := m.TotalUnbondedDelegation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.TotalBondedDelegation.Size()
		i -= size
		if _, err := m.TotalBondedDelegation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TotalResourceNodesDeposit.Size()
		i -= size
		if _, err := m.TotalResourceNodesDeposit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalMinedTokens.Size()
		i -= size
		if _, err := m.TotalMinedTokens.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalMiningSupply.Size()
		i -= size
		if _, err := m.TotalMiningSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalSupply.Size()
		i -= size
		if _, err := m.TotalSupply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPot(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintPot(dAtA []byte, offset int, v uint64) int {
	offset -= sovPot(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondDenom)
	if l > 0 {
		n += 1 + l + sovPot(uint64(l))
	}
	l = len(m.RewardDenom)
	if l > 0 {
		n += 1 + l + sovPot(uint64(l))
	}
	if m.MatureEpoch != 0 {
		n += 1 + sovPot(uint64(m.MatureEpoch))
	}
	if len(m.MiningRewardParams) > 0 {
		for _, e := range m.MiningRewardParams {
			l = e.Size()
			n += 1 + l + sovPot(uint64(l))
		}
	}
	l = m.CommunityTax.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.InitialTotalSupply.Size()
	n += 1 + l + sovPot(uint64(l))
	return n
}

func (m *MiningRewardParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalMinedValveStart.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.TotalMinedValveEnd.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.MiningReward.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.BlockChainPercentageInBp.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.ResourceNodePercentageInBp.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.MetaNodePercentageInBp.Size()
	n += 1 + l + sovPot(uint64(l))
	return n
}

func (m *Reward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WalletAddress)
	if l > 0 {
		n += 1 + l + sovPot(uint64(l))
	}
	if len(m.RewardFromMiningPool) > 0 {
		for _, e := range m.RewardFromMiningPool {
			l = e.Size()
			n += 1 + l + sovPot(uint64(l))
		}
	}
	if len(m.RewardFromTrafficPool) > 0 {
		for _, e := range m.RewardFromTrafficPool {
			l = e.Size()
			n += 1 + l + sovPot(uint64(l))
		}
	}
	return n
}

func (m *SingleWalletVolume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WalletAddress)
	if l > 0 {
		n += 1 + l + sovPot(uint64(l))
	}
	l = m.Volume.Size()
	n += 1 + l + sovPot(uint64(l))
	return n
}

func (m *WalletVolumes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovPot(uint64(l))
		}
	}
	return n
}

func (m *VolumeReportRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovPot(uint64(l))
	}
	l = len(m.ReportReference)
	if l > 0 {
		n += 1 + l + sovPot(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovPot(uint64(l))
	}
	return n
}

func (m *TotalReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MiningReward) > 0 {
		for _, e := range m.MiningReward {
			l = e.Size()
			n += 1 + l + sovPot(uint64(l))
		}
	}
	if len(m.TrafficReward) > 0 {
		for _, e := range m.TrafficReward {
			l = e.Size()
			n += 1 + l + sovPot(uint64(l))
		}
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalSupply.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.TotalMiningSupply.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.TotalMinedTokens.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.TotalResourceNodesDeposit.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.TotalBondedDelegation.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.TotalUnbondedDelegation.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.TotalUnbondingDelegation.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.CirculationSupply.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.TotalMiningReward.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.ChainMiningReward.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.ResourceMiningReward.Size()
	n += 1 + l + sovPot(uint64(l))
	l = m.MetaMiningReward.Size()
	n += 1 + l + sovPot(uint64(l))
	return n
}

func sovPot(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPot(x uint64) (n int) {
	return sovPot(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatureEpoch", wireType)
			}
			m.MatureEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatureEpoch |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningRewardParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MiningRewardParams = append(m.MiningRewardParams, MiningRewardParam{})
			if err := m.MiningRewardParams[len(m.MiningRewardParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunityTax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommunityTax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialTotalSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InitialTotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MiningRewardParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MiningRewardParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MiningRewardParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinedValveStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMinedValveStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinedValveEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMinedValveEnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MiningReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockChainPercentageInBp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockChainPercentageInBp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceNodePercentageInBp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceNodePercentageInBp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaNodePercentageInBp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MetaNodePercentageInBp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardFromMiningPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardFromMiningPool = append(m.RewardFromMiningPool, types.Coin{})
			if err := m.RewardFromMiningPool[len(m.RewardFromMiningPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardFromTrafficPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardFromTrafficPool = append(m.RewardFromTrafficPool, types.Coin{})
			if err := m.RewardFromTrafficPool[len(m.RewardFromTrafficPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleWalletVolume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleWalletVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleWalletVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Volume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletVolumes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletVolumes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletVolumes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, SingleWalletVolume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeReportRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeReportRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeReportRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportReference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportReference = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiningReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MiningReward = append(m.MiningReward, types.Coin{})
			if err := m.MiningReward[len(m.MiningReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrafficReward = append(m.TrafficReward, types.Coin{})
			if err := m.TrafficReward[len(m.TrafficReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMiningSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMiningSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinedTokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMinedTokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResourceNodesDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalResourceNodesDeposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBondedDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBondedDelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUnbondedDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalUnbondedDelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUnbondingDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalUnbondingDelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CirculationSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CirculationSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMiningReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalMiningReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainMiningReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChainMiningReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceMiningReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceMiningReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaMiningReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPot
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPot
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MetaMiningReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPot(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPot(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPot
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPot
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPot
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPot
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPot
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPot
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPot        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPot          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPot = fmt.Errorf("proto: unexpected end of group")
)
